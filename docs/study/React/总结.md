## 使用

React事件

1. event 是SyntheticEvent，模拟dom事件所有能力
2. event.nativeEvent是元素事件对象
3. 所有的事件都被挂载到document上

React事件与原生事件执行顺序

```jsx
import  React  from 'react';
class App extends React.Component{

  constructor(props) {
    super(props);
    this.parentRef = React.createRef();
    this.childRef = React.createRef();
  }
  componentDidMount() {
    console.log("React componentDidMount！");
    this.parentRef.current?.addEventListener("click", () => {
      console.log("原生事件：父元素 DOM 事件监听！");
    });
    this.childRef.current?.addEventListener("click", () => {
      console.log("原生事件：子元素 DOM 事件监听！");
    });
    document.addEventListener("click", (e) => {
      console.log("原生事件：document DOM 事件监听！");
    });
  }
  parentClickFun = () => {
    console.log("React 事件：父元素事件监听！");
  };
  childClickFun = () => {
    console.log("React 事件：子元素事件监听！");
  };
  render() {
    return (
      <div ref={this.parentRef} onClick={this.parentClickFun}>
        <div ref={this.childRef} onClick={this.childClickFun}>
          分析事件执行顺序
        </div>
      </div>
    );
  }
}
export default App;
```

结果

```tcl
原生事件：子元素 DOM 事件监听！ 
原生事件：父元素 DOM 事件监听！ 
React 事件：子元素事件监听！ 
React 事件：父元素事件监听！ 
原生事件：document DOM 事件监听！ 
```

受控组件 value  input、textarea  onChange

#### 为什么要合成事件机制

+ 更好的兼容性和跨平台
+ 挂载到document上，减少内存消耗，避免频繁解绑
+ 方便事件的统一管理（如事务机制）



在setState前不能修改state值

```js
//数组
this.state({
    list1:this.state.list1.concat(100),  //追加
    list2:[...this.state.list2,100],   //追加
    list3:this.state.list3.slice(0,3),  //截取
    list4:this.state.list4.filter(item=>item>100),  //筛选
    list5:list5.slice().   //其他操作
    
    //不能直接对this.state.list进行push pop splice等，这样违反不可变原则
})

//对象
this.setState({
    obj1:Object.assign({},this.state.obj1,{a:100}),
    obj2:{...this.state.obj2,a:100}
    
    //不能直接对this.state.obj进行属性设置。这样违反不可变值
})

```



- 在组件生命周期或React合成事件中，setState是异步
- 在setTimeout或者原生dom事件中，setState是同步

异步更新，更新前会合并

```js
//传入对象，会被合并(类似Object.assign)。执行结果只一次+1
this.setState({
    count:this.state.count+1;
})
this.setState({
    count:this.state.count+1;
})
this.setState({
    count:this.state.count+1;
})

//传入函数，不会被合并，执行结果+3
this.setState((preState,props)=>{
    return{
        count:prevState.count+1
    }
})
this.setState((preState,props)=>{
    return{
        count:prevState.count+1
    }
})
this.setState((preState,props)=>{
    return{
        count:prevState.count+1
    }
})
```

函数组件和class组件的区别

函数组件

+ 纯函数，输入props，输出JSX
+ 没有实例，没有生命周期，没有state
+ 不能扩展其他方法

受控组件：就是受我们控制的组件，组件的状态全程响应外部数据

```jsx
<input value={this.state.name} onChange={this.onChange.bind(this)} />
onChange=(value)=>{
    this.setState({
        name: value
    });
}
```

非受控组件

```jsx
<input defaultValue={this.state.value} ref={this.nameInputRef}/>

alertName=()=>{
    const elem=name.nameInputRef.current;  //通过ref获取dom节点
    alert(elem.value); //不能通过state获取元素的值
}

<input type="checkbox" defaultChecked={this.state.flag}/>  //checked的变化不会同步到state中
```

使用场景

+ 必须手动操作DOM元素，setState实现不了
+ 文件上传<input type="flie">
+ 某些富文本编辑器，需要传入DOM元素

选择

+ 优先使用受控组件，符合React设计原则
+ 必须操作DOM，再使用非受控组件

### context

公共信息（语言，主题）的传递，用props太繁琐，用redux小题大做

### 异步组件

React.lazy

React.Suspense

组件比较大或者

### 

+ PureComponent，SCU中实现浅比较，class组件
+ memo,函数组件中的PureComponent
+ 浅比较已使用大部分情况



immutable，不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据

对 `Immutable`对象的任何修改或添加删除操作都会返回一个新的 `Immutable`对象

`Immutable` 实现的原理是 `Persistent Data Structure`（持久化数据结构）:

- 用一种数据结构来保存数据
- 当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费

也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变，同时为了避免 `deepCopy`把所有节点都复制一遍带来的性能损耗，`Immutable` 使用了 `Structural Sharing`（结构共享）

如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享

## 原理

